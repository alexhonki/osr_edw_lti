'use strict';

var _ = require('lodash');
var URI = require('urijs');
var path = require('path');
var VError = require('verror').VError;
var JsonValidator = require('../utils/JsonValidator');
var fsUtils = require('../utils/fs-utils');
var xsAppSchema = require('./schemas/xs-app-schema');
var sourceSchema = require('./schemas/refs/source-schema');
var scopesSchema = require('./schemas/refs/scopes-schema');
var pluginsSchema = require('./schemas/plugins-schema');
var headersSchema = require('./schemas/headers-schema');
var whitelistSchema = require('./schemas/whitelist-schema');
var environmentSchema = require('./schemas/environment-schema');
var envDestinationsSchema = require('./schemas/destinations-schema');
var approuterOptionsSchema = require('./schemas/options-schema');
var uaaOptionsSchema = require('./schemas/uaa-config-schema');
var corsSchema = require('./schemas/refs/cors-schema');
var connectivitySchema = require('./schemas/connectivity-config-schema');


module.exports = {
  validateXsApp: function(configuration, envDestinations, directory) {
    addConfigurationDefaults(configuration);

    var validator = new JsonValidator();
    validator.addSchema('sourceSchema', sourceSchema);
    validator.addSchema('scopesSchema', scopesSchema);
    validator.addFormat('relative-uri', validateRelativeUri);
    validator.addFormat('local-file', validateLocalFile.bind(null, directory));
    validator.addFormat('uri', validateUri);
    validator.addFormat('regex', validateRegex);
    validator.addFormat('valid-header-value', validateHeaderValue);

    validator.addFormat('route-rules', function(route) {
      if (!route.destination && !route.localDir) {
        return 'Route does not have a destination nor a localDir';
      }

      if (route.destination) {
        if (envDestinations && !envDestinations[route.destination]) {
          return 'Route references unknown destination "' + route.destination + '"';
        }
        if (route.localDir) {
          return 'Route has both localDir and destination';
        }
      }

      if (route.localDir) {
        var fullPath = path.join(directory, route.localDir);
        if (!fsUtils.isDirectory(fullPath)) {
          return fullPath + ' is not a directory';
        }

        if (Array.isArray(route.httpMethods)) {
          return 'Route has both localDir and httpMethods';
        }
      } else {
        var forbiddenProperties = ['replace', 'cacheControl'];
        for (var i = 0; i < forbiddenProperties.length; i++) {
          if (route[forbiddenProperties[i]]) {
            return 'Route has ' + forbiddenProperties[i] + ' with no localDir';
          }
        }
      }
    });

    validator.addFormat('logout-rules', function (logout) {
      if (logout.logoutPage && !logout.logoutEndpoint) {
        return 'Logout page is set although logout endpoint is not configured';
      }
    });

    validator.validate(configuration, xsAppSchema, 'xs-app.json');

    var routeDestinations = _.map(configuration.routes || [], 'destination').filter(_.identity);
    var unusedDestinations = _.difference(Object.keys(configuration.destinations || {}), routeDestinations);
    if (unusedDestinations.length > 0) {
      throw new VError('Destination(s) "%s" not used by any route', unusedDestinations);
    }
  },

  validateEnvDestinations: function(configuration) {
    var validator = new JsonValidator();

    validator.addFormat('no-duplicate-names', function(destinations) {
      var duplicates = _.chain(destinations).countBy('name').pickBy(function(count) { return count > 1; }).keys().value();
      if (duplicates.length > 0) {
        return 'Duplicate destination names: ' + duplicates;
      }
    });

    validator.addFormat('valid-port', function(proxyPort) {
      return validatePort(proxyPort, 'Destination "proxyPort"');
    });

    validator.addFormat('absolute-uri', validateAbsoluteUri);

    validator.validate(configuration, envDestinationsSchema, 'environment-destinations');
  },

  validateEnvironmentSettings: function(configuration) {
    var validator = new JsonValidator();
    validator.addFormat('regexWithCapture', validateRegexWithCapture);
    validator.validate(configuration, environmentSchema, 'environment-settings');
  },

  validatePlugins: function(configuration, envDestinations) {
    var validator = new JsonValidator();
    validator.addSchema('sourceSchema', sourceSchema);
    validator.addSchema('scopesSchema', scopesSchema);
    validator.addFormat('regex', validateRegex);
    validator.addFormat('relative-uri', validateRelativeUri);

    validator.addFormat('plugin-rules', function(plugin) {
      if (envDestinations && plugin.destination && !envDestinations[plugin.destination]) {
        return 'Plugin references destination "' + plugin.destination + '", which cannot be found in the environment';
      }
    });

    validator.validate(configuration, pluginsSchema, 'plugins');
  },

  validateHeaders: function(configuration) {
    var validator = new JsonValidator();
    validator.addFormat('valid-header-value', validateHeaderValue);
    validator.addFormat('headers-rules', function(header) {
      var key = Object.keys(header)[0];
      var headerNamePattern = /^[!#$%&'*+\-.^_`|~0-9a-zA-Z]+$/; // http://tools.ietf.org/html/rfc7230#section-3.2.6
      if (!headerNamePattern.test(key)) {
        return 'Header does not have a valid name';
      }

      var headerName = key.match(headerNamePattern)[0];
      if (headerName.toLowerCase() === 'set-cookie' || headerName.toLowerCase() === 'cookie') {
        return 'Headers "set-cookie" and "cookie" are not allowed in the additional headers';
      }
    });

    validator.validate(configuration, headersSchema, 'http-headers');
  },

  validateWhitelist: function(whitelist) {
    var validator = new JsonValidator();
    validator.addFormat('hostname-rules', function(listItem) {
      var regexHostName = /^(\*\.)?(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])$/;
      var regexIPHostName = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;

      if (!(regexHostName.test(listItem.host) || regexIPHostName.test(listItem.host))) {
        return 'Whitelist item\'s host "' + listItem.host + '" is not correct. Possible values allow valid hostname, IP or hostname prefixed with *.';
      }
    });

    validator.addFormat('valid-port', function(port) {
      return validatePort(port, 'Whitelist item\'s port');
    });

    validator.validate(whitelist, whitelistSchema, 'clickjack-whitelist');
  },

  validateApprouterStartOptions: function(options) {
    var validator = new JsonValidator();
    validator.addFormat('valid-port', function(port) {
      if (port === 0) {
        return;
      }
      return validatePort(port, 'Approuter port');
    });
    validator.addFormat('function', function functionFormat(data) {
      if (typeof data !== 'function') {
        return 'Function expected';
      }
    });

    validator.validate(options, approuterOptionsSchema, 'options');
  },

  validateUaaOptions: function(options) {
    var validator = new JsonValidator();
    validator.addFormat('absolute-uri', validateAbsoluteUri);

    validator.validate(options, uaaOptionsSchema, 'uaa-configuration');
  },

  validateConnectivityCredentials: function(options) {
    var validator = new JsonValidator();
    validator.addFormat('absolute-uri', validateAbsoluteUri);

    validator.validate(options, connectivitySchema, 'connectivity-configuration');
  },

  validateCors: function(options) {
    var validator = new JsonValidator();
    validator.addFormat('regex', validateRegex);
    validator.addFormat('validateWhitelist', exports.validateWhitelist);
    validator.addSchema('sourceSchema', sourceSchema);
    validator.validate(options, corsSchema, 'cors-configuration');
  }
};

function addConfigurationDefaults(configuration) {
  var defaultSessionTimeoutInMinutes = 15;
  var defaultLoginCallback = '/login/callback';
  var websocketsEnabledByDefault = false;
  var compressionEnabledByDefault = true;

  _.defaultsDeep(configuration, { compression: { enabled: compressionEnabledByDefault } });
  configuration.sessionTimeout = configuration.sessionTimeout || defaultSessionTimeoutInMinutes;
  configuration.login = getPropertyValue(configuration, 'login', { callbackEndpoint: defaultLoginCallback });
  configuration.websockets = getPropertyValue(configuration, 'websockets', { enabled: websocketsEnabledByDefault });
}

function getPropertyValue(configObject, propertyName, defaultValue) {
  if (configObject.hasOwnProperty(propertyName)) {
    return configObject[propertyName];
  }
  return defaultValue;
}

function validateRelativeUri(relativeUri) {
  var components = URI.parse(relativeUri);
  if (components.protocol || components.hostname) {
    return 'URI must be a relative path';
  }
}

function validateLocalFile(directory, file) {
  var fullPath = path.join(directory, file);
  if (!fsUtils.isFile(fullPath)) {
    return fullPath + ' is not a file';
  }
}

function validateAbsoluteUri(uri) {
  var components = URI.parse(uri);
  if (!components.protocol || !components.hostname) {
    return 'URI must be absolute';
  }
  var supportedProtocols = ['http', 'https', 'ws', 'wss'];
  if (!_.includes(supportedProtocols, components.protocol)) {
    return 'URI has unsupported protocol, supported protocols are ' + supportedProtocols;
  }
}

function validateUri(uri) {
  var components = URI.parse(uri);
  if (components.protocol && components.protocol !== 'http' && components.protocol !== 'https') {
    return "Supported schemes are 'http' and 'https'";
  }
}

function validateRegex(regex) {
  var regexToCheck = _.isObject(regex) ? regex.path : regex;
  try {
    RegExp(regexToCheck);
  } catch (exception) {
    return exception;
  }
}

function validateRegexWithCapture(regex) {
  var regexError = validateRegex(regex);
  if (regexError) {
    return regexError;
  }
  if (regex.indexOf('(') === -1) {
    return 'regular expression must contain a capturing group';
  }
}

function validatePort(port, messagePrefix) {
  var portMinValue = 1;
  var portMaxValue = 65535;
  if (typeof port === 'string' && !/^[1-9]\d*$/.test(port)) {
    return messagePrefix + ' value is string, which cannot be parsed as positive integer';
  }
  port = parseFloat(port);
  if (port < portMinValue || port > portMaxValue) {
    return messagePrefix + ' value has to be string or integer between ' + portMinValue + '-' + portMaxValue;
  }
}

function validateHeaderValue(headerValue) {
  // Inspired by Node.js: https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js
  var headerValueIsValid = headerValue.split('').map(function(character) {
    return character.charCodeAt(0);
  }).every(function(charCode) {
    return (charCode > 31 && charCode <= 255 && charCode !== 127) || charCode === 9;
  });

  if (!headerValueIsValid) {
    return 'The header content contains invalid characters';
  }
}
